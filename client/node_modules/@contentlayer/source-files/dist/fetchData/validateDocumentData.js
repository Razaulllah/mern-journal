import { filePathJoin, fs } from '@contentlayer/utils';
import { O, OT, pipe, T, These } from '@contentlayer/utils/effect';
import micromatch from 'micromatch';
import { FetchDataError } from '../errors/index.js';
import { DocumentTypeMapState } from './DocumentTypeMap.js';
export const validateDocumentData = ({ coreSchemaDef, rawContent, relativeFilePath, filePathPatternMap, options, contentDirPath, contentTypeMap, }) => pipe(T.gen(function* ($) {
    const documentDefName = getDocumentDefName({ rawContent, filePathPatternMap, relativeFilePath, options });
    yield* $(OT.addAttribute('documentDefName', documentDefName));
    if (documentDefName === undefined) {
        const typeFieldName = options.fieldOptions.typeFieldName;
        return These.fail(new FetchDataError.CouldNotDetermineDocumentTypeError({ documentFilePath: relativeFilePath, typeFieldName }));
    }
    const documentTypeDef = coreSchemaDef.documentTypeDefMap[documentDefName];
    if (documentTypeDef === undefined) {
        return These.fail(new FetchDataError.NoSuchDocumentTypeError({
            documentTypeName: documentDefName,
            documentFilePath: relativeFilePath,
        }));
    }
    const contentType = contentTypeMap[documentTypeDef.name];
    const mismatchError = validateContentTypeMatchesFileExtension({ contentType, relativeFilePath });
    if (mismatchError)
        return These.fail(mismatchError);
    yield* $(DocumentTypeMapState.update((_) => _.add(documentDefName, relativeFilePath)));
    const requiredFieldError = validateRequiredFieldValues({
        rawFieldValues: rawContent.fields,
        documentFilePath: relativeFilePath,
        documentTypeDef,
        fieldDefs: documentTypeDef.fieldDefs,
    });
    if (O.isSome(requiredFieldError)) {
        return These.fail(requiredFieldError.value);
    }
    const warningOption = validateExtraFieldValues({
        fieldDefs: documentTypeDef.fieldDefs,
        rawFieldValues: rawContent.fields,
        options,
        documentTypeDef,
        documentFilePath: relativeFilePath,
    });
    for (const fieldDef of documentTypeDef.fieldDefs) {
        const fieldValidOption = yield* $(validateFieldData({
            documentFilePath: relativeFilePath,
            documentTypeDef,
            fieldDef,
            coreSchemaDef,
            rawFieldData: rawContent.fields[fieldDef.name],
            contentDirPath,
        }));
        if (O.isSome(fieldValidOption)) {
            return These.fail(fieldValidOption.value);
        }
    }
    return These.warnOption({ documentTypeDef }, warningOption);
}), OT.withSpan('validateDocumentData', { attributes: { relativeFilePath } }));
const getDocumentDefName = ({ rawContent, relativeFilePath, filePathPatternMap, options, }) => {
    // first check if provided document has a type field value
    const typeFieldName = options.fieldOptions.typeFieldName;
    const typeFieldValue = rawContent.fields[typeFieldName];
    if (typeFieldValue !== undefined) {
        return typeFieldValue;
    }
    // otherwise try to see whether one of the document type definitions has a file path pattern
    // that matches the file path
    return getDocumentDefNameByFilePathPattern({ filePathPatternMap, relativeFilePath });
};
const getDocumentDefNameByFilePathPattern = ({ relativeFilePath, filePathPatternMap, }) => {
    const matchingFilePathPattern = Object.keys(filePathPatternMap).find((filePathPattern) => micromatch.isMatch(relativeFilePath, filePathPattern, {}));
    if (matchingFilePathPattern) {
        return filePathPatternMap[matchingFilePathPattern];
    }
    return undefined;
};
const validateFieldData = ({ fieldDef, rawFieldData, documentFilePath, coreSchemaDef, documentTypeDef, contentDirPath, }) => T.gen(function* ($) {
    const dataIsNil = rawFieldData === undefined || rawFieldData === null;
    if (dataIsNil && fieldDef.isRequired === false) {
        return O.none;
    }
    switch (fieldDef.type) {
        case 'list':
            return Array.isArray(rawFieldData)
                ? O.none
                : O.some(new FetchDataError.IncompatibleFieldDataError({
                    incompatibleFieldData: [[fieldDef.name, rawFieldData]],
                    documentFilePath,
                    documentTypeDef,
                }));
        // TODO also check for references in lists
        case 'reference':
            if (typeof rawFieldData === 'string') {
                const fullFilePath = filePathJoin(contentDirPath, rawFieldData);
                const fileExists = yield* $(fs.fileOrDirExists(fullFilePath));
                if (!fileExists) {
                    return O.some(new FetchDataError.ReferencedFileDoesNotExistError({
                        referencedFilePath: rawFieldData,
                        fieldName: fieldDef.name,
                        documentFilePath,
                        documentTypeDef,
                    }));
                }
            }
            return O.none;
        case 'nested_unnamed':
        case 'nested': {
            const nestedFieldDefs = fieldDef.type === 'nested_unnamed'
                ? fieldDef.typeDef.fieldDefs
                : coreSchemaDef.nestedTypeDefMap[fieldDef.nestedTypeName].fieldDefs;
            const nestedFieldError = validateRequiredFieldValues({
                documentFilePath,
                documentTypeDef,
                fieldDefs: nestedFieldDefs,
                rawFieldValues: rawFieldData,
            });
            if (O.isSome(nestedFieldError))
                return nestedFieldError;
            // TODO also check for extra fields (but this will require a refactor)
            for (const fieldDef of nestedFieldDefs) {
                const fieldValidOption = yield* $(validateFieldData({
                    documentFilePath,
                    documentTypeDef,
                    coreSchemaDef,
                    fieldDef,
                    rawFieldData: rawFieldData[fieldDef.name],
                    contentDirPath,
                }));
                if (O.isSome(fieldValidOption)) {
                    return fieldValidOption;
                }
            }
            return O.none;
        }
        case 'nested_polymorphic': // TODO
        // TODO validate whether data has correct type (probably via zod)
        default:
            return O.none;
    }
})['|>'](T.orDie);
const validateRequiredFieldValues = ({ rawFieldValues, fieldDefs, documentTypeDef, documentFilePath, }) => {
    const existingDataFieldKeys = Object.keys(rawFieldValues);
    const requiredFieldsWithoutDefaultValue = fieldDefs.filter((_) => _.isRequired && _.default === undefined && _.isSystemField === false);
    const misingRequiredFieldDefs = requiredFieldsWithoutDefaultValue.filter((fieldDef) => !existingDataFieldKeys.includes(fieldDef.name));
    if (misingRequiredFieldDefs.length > 0) {
        return O.some(new FetchDataError.MissingRequiredFieldsError({
            documentFilePath,
            documentTypeDef,
            fieldDefsWithMissingData: misingRequiredFieldDefs,
        }));
    }
    return O.none;
};
const validateExtraFieldValues = ({ rawFieldValues, fieldDefs, options, documentTypeDef, documentFilePath, }) => {
    const existingDataFieldKeys = Object.keys(rawFieldValues);
    // warn about data fields not defined in the schema
    const typeFieldName = options.fieldOptions.typeFieldName;
    // NOTE we also need to add the system-level type name field to the list of existing data fields
    const schemaFieldNames = fieldDefs.map((_) => _.name).concat([typeFieldName]);
    const extraFieldEntries = existingDataFieldKeys
        .filter((fieldKey) => !schemaFieldNames.includes(fieldKey))
        .map((fieldKey) => [fieldKey, rawFieldValues[fieldKey]]);
    if (extraFieldEntries.length > 0) {
        return O.some(new FetchDataError.ExtraFieldDataError({
            documentFilePath,
            extraFieldEntries,
            documentTypeDef,
        }));
    }
    return O.none;
};
const validateContentTypeMatchesFileExtension = ({ contentType, relativeFilePath, }) => {
    const extension = relativeFilePath.toLowerCase().split('.').pop();
    const validMarkdownExtensions = ['md', 'mdx'];
    const isInvalidMarkdownOrMdx = (contentType === 'markdown' || contentType === 'mdx') && validMarkdownExtensions.includes(extension) === false;
    const validDataExtensions = ['json', 'yaml', 'yml'];
    const isInvalidData = contentType === 'data' && validDataExtensions.includes(extension) === false;
    if (isInvalidMarkdownOrMdx || isInvalidData) {
        return new FetchDataError.FileExtensionMismatch({ contentType, extension, filePath: relativeFilePath });
    }
    return undefined;
};
//# sourceMappingURL=validateDocumentData.js.map