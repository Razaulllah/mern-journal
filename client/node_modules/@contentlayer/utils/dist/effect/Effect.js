// ets_tracing: off
import { Cause, Chunk, Effect as T, Either as E, pipe } from '@effect-ts/core';
import * as Tuple from '@effect-ts/core/Collections/Immutable/Tuple';
import { ConsoleService } from './ConsoleService.js';
export * from '@effect-ts/core/Effect';
// export const log = (...args: any[]) =>
//   T.succeedWith(() => {
//     console.log(...args)
//   })
// NOTE this is temporary until Stackblitz supports deconstructed exports
// export const { log } = T.deriveLifted(ConsoleService)(['log'], [], [])
const log_ = T.deriveLifted(ConsoleService)(['log'], [], []);
export const log = log_.log;
export const rightOrFail = (effect, __trace) => T.chain_(effect, E.fold((x) => T.fail(x, __trace), (x) => T.succeed(x, __trace)));
/** Logs both on errors and defects */
export const tapCauseLogPretty = (eff) => T.tapCause_(eff, (err) => T.succeedWith(() => console.error(Cause.pretty(err))));
export const debugLogEnv = (msg) => pipe(T.environment(), T.tap((env) => log(msg ?? 'debugLogEnv', env)));
export const tryPromiseOrDie = (promise) => pipe(T.tryPromise(promise), T.orDie);
export const sync = (fn) => T.succeedWith(fn);
export const eitherMap = (mapRight) => (effect, __trace) => T.map_(effect, E.map(mapRight));
export const chainMergeObject = (effect) => (self) => T.chain_(self, (a1) => pipe(effect(a1), T.map((a2) => ({ ...a1, ...a2 }))));
export const forEachParDict = (args) => (as) => forEachParDict_(as, args);
export const forEachParDict_ = (as, { mapKey, mapValue, }) => pipe(as, T.forEach((a) => T.tuplePar(mapKey(a), mapValue(a))), T.map(Chunk.map(Tuple.toNative)), T.map(Chunk.toArray), T.map(Object.fromEntries));
export const tapSync = (tapFn) => (eff) => T.tap_(eff, (a) => T.succeedWith(() => tapFn(a)));
//# sourceMappingURL=Effect.js.map