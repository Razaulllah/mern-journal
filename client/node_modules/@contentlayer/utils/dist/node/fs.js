import { promises as fs } from 'node:fs';
import { pipe } from '@effect-ts/core';
import * as OT from '@effect-ts/otel';
import { L, T } from '../effect/index.js';
import { FileNotFoundError, FileOrDirNotFoundError, FsTag, JsonParseError, JsonStringifyError, MkdirError, ReadFileError, RmError, StatError, SymlinkError, WriteFileError, } from '../fs_.js';
const fileOrDirExists = (pathLike) => {
    return pipe(stat(pathLike), T.map((stat_) => stat_.isFile() || stat_.isDirectory()), T.catchTag('fs.FileNotFoundError', () => T.succeed(false)), T.tap((exists) => OT.addAttribute('exists', exists)), OT.withSpan('fileOrDirExists', { attributes: { pathLike } }));
};
const symlinkExists = (pathLike) => {
    return pipe(stat(pathLike), T.map((stat_) => stat_.isSymbolicLink()), T.catchTag('fs.FileNotFoundError', () => T.succeed(false)));
};
const stat = (filePath) => {
    return T.tryCatchPromise(async () => fs.stat(filePath), (error) => {
        if (error.code === 'ENOENT') {
            return new FileNotFoundError({ filePath });
        }
        else {
            return new StatError({ filePath, error });
        }
    });
};
const readFile = (filePath) => OT.withSpan('readFile', { attributes: { filePath } })(T.tryCatchPromise(() => fs.readFile(filePath, 'utf8'), (error) => {
    if (error.code === 'ENOENT') {
        return new FileNotFoundError({ filePath });
    }
    else {
        return new ReadFileError({ filePath, error });
    }
}));
const readFileBuffer = (filePath) => OT.withSpan('readFileBuffer', { attributes: { filePath } })(T.tryCatchPromise(() => fs.readFile(filePath), (error) => {
    if (error.code === 'ENOENT') {
        return new FileNotFoundError({ filePath });
    }
    else {
        return new ReadFileError({ filePath, error });
    }
}));
const readFileJson = (filePath) => pipe(readFile(filePath), T.chain((str) => T.tryCatch(() => JSON.parse(str), (error) => new JsonParseError({ str, error }))));
const readFileJsonIfExists = (filePath) => pipe(fileOrDirExists(filePath), T.chain((exists) => (exists ? readFileJson(filePath) : T.succeed(undefined))), T.catchTag('fs.FileNotFoundError', (e) => T.die(e)));
const writeFile = (filePath, content) => OT.withSpan('writeFile', { attributes: { filePath } })(T.tryCatchPromise(() => fs.writeFile(filePath, content, 'utf8'), (error) => new WriteFileError({ filePath, error })));
const writeFileJson = ({ filePath, content, }) => pipe(T.tryCatch(() => JSON.stringify(content, null, 2) + '\n', (error) => new JsonStringifyError({ error })), T.chain((contentStr) => writeFile(filePath, contentStr)));
const mkdirp = (dirPath) => OT.withSpan('mkdirp', { attributes: { dirPath } })(T.tryCatchPromise(() => fs.mkdir(dirPath, { recursive: true }), (error) => new MkdirError({ dirPath, error })));
function rm(path, params = {}) {
    const { force = false, recursive = true } = params;
    return OT.withSpan('rm', { attributes: { path } })(T.tryCatchPromise(() => fs.rm(path, { recursive, force }), (error) => {
        if (error.code === 'ENOENT') {
            return new FileOrDirNotFoundError({ path });
        }
        else {
            return new RmError({ path, error });
        }
    }));
}
/**
 * NOTE: symlinks are not supported widely on Windows
 */
const symlink = ({ targetPath, symlinkPath, type, }) => OT.withSpan('symlink', { attributes: { targetPath, symlinkPath, type } })(T.tryCatchPromise(() => fs.symlink(targetPath, symlinkPath, type), (error) => new SymlinkError({ targetPath, symlinkPath, type, error })));
export const NodeFsLive = L.fromValue(FsTag)({
    fileOrDirExists,
    symlinkExists,
    stat,
    readFile,
    readFileBuffer,
    readFileJson,
    readFileJsonIfExists,
    writeFile,
    writeFileJson,
    mkdirp,
    rm,
    symlink,
});
//# sourceMappingURL=fs.js.map