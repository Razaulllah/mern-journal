import { fs } from 'memfs';
import { L, OT, pipe, T } from './effect/index.js';
import { FileNotFoundError, FileOrDirNotFoundError, FsTag, JsonParseError, JsonStringifyError, MkdirError, ReadFileError, RmError, StatError, SymlinkError, WriteFileError, } from './fs_.js';
export const fileOrDirExists = (pathLike) => {
    return pipe(stat(pathLike), T.map((stat_) => stat_.isFile() || stat_.isDirectory()), T.catchTag('fs.FileNotFoundError', () => T.succeed(false)), T.tap((exists) => OT.addAttribute('exists', exists)), OT.withSpan('fileOrDirExists', { attributes: { pathLike } }));
};
export const symlinkExists = (pathLike) => {
    return pipe(stat(pathLike), T.map((stat_) => stat_.isSymbolicLink()), T.catchTag('fs.FileNotFoundError', () => T.succeed(false)));
};
export const stat = (filePath) => {
    return T.tryCatch(() => fs.statSync(filePath), (error) => {
        if (error.code === 'ENOENT') {
            return new FileNotFoundError({ filePath });
        }
        else {
            return new StatError({ filePath, error });
        }
    });
};
export const readFile = (filePath) => OT.withSpan('readFile', { attributes: { filePath } })(T.tryCatch(() => fs.readFileSync(filePath, 'utf8'), (error) => {
    if (error.code === 'ENOENT') {
        return new FileNotFoundError({ filePath });
    }
    else {
        return new ReadFileError({ filePath, error });
    }
}));
export const readFileBuffer = (filePath) => OT.withSpan('readFileBuffer', { attributes: { filePath } })(T.tryCatch(() => fs.readFileSync(filePath, { encoding: 'buffer' }), (error) => {
    if (error.code === 'ENOENT') {
        return new FileNotFoundError({ filePath });
    }
    else {
        return new ReadFileError({ filePath, error });
    }
}));
export const readFileJson = (filePath) => pipe(readFile(filePath), T.chain((str) => T.tryCatch(() => JSON.parse(str), (error) => new JsonParseError({ str, error }))));
export const readFileJsonIfExists = (filePath) => pipe(fileOrDirExists(filePath), T.chain((exists) => (exists ? readFileJson(filePath) : T.succeed(undefined))), T.catchTag('fs.FileNotFoundError', (e) => T.die(e)));
export const writeFile = (filePath, content) => OT.withSpan('writeFile', { attributes: { filePath } })(T.tryCatch(() => fs.writeFileSync(filePath, content, { encoding: 'utf8' }), (error) => new WriteFileError({ filePath, error })));
export const writeFileJson = ({ filePath, content, }) => pipe(T.tryCatch(() => JSON.stringify(content, null, 2) + '\n', (error) => new JsonStringifyError({ error })), T.chain((contentStr) => writeFile(filePath, contentStr)));
export const mkdirp = (dirPath) => OT.withSpan('mkdirp', { attributes: { dirPath } })(T.tryCatch(() => fs.mkdirpSync(dirPath), (error) => new MkdirError({ dirPath, error })));
export function rm(path, params = {}) {
    const { force = false, recursive = true } = params;
    return OT.withSpan('rm', { attributes: { path } })(T.tryCatch(() => fs.rmSync(path, { recursive, force }), (error) => {
        if (error.code === 'ENOENT') {
            return new FileOrDirNotFoundError({ path });
        }
        else {
            return new RmError({ path, error });
        }
    }));
}
/**
 * NOTE: symlinks are not supported widely on Windows
 */
export const symlink = ({ targetPath, symlinkPath, type, }) => OT.withSpan('symlink', { attributes: { targetPath, symlinkPath, type } })(T.tryCatch(() => fs.symlinkSync(targetPath, symlinkPath, type), (error) => new SymlinkError({ targetPath, symlinkPath, type, error })));
export const InMemoryFsLive = L.fromValue(FsTag)({
    fileOrDirExists,
    symlinkExists,
    stat,
    readFile,
    readFileBuffer,
    readFileJson,
    readFileJsonIfExists,
    writeFile,
    writeFileJson,
    mkdirp,
    rm,
    symlink,
});
//# sourceMappingURL=fs-in-memory.js.map