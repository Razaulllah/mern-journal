import type * as O from "../../../Option/index.js";
import * as P from "../../../Prelude/index.js";
import type * as A from "./operations.js";
export declare const sequence: <F extends P.URIS, FC>(App: P.Covariant<F, FC> & P.IdentityBoth<F, FC>) => <K, Q, W, X, I, S, R, E, FK, FQ, FW, FX, FI, FS, FR, FE, A>(_: A.NonEmptyArray<F extends [any, ...infer Next] ? P.URItoKind<F[0]["_C"], FC, P.OrFix<"K", F[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", F[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", F[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", F[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", F[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", F[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", F[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", F[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, any>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[F[0]["_F"]] : A>) => F extends [any, ...infer Next] ? P.URItoKind<F[0]["_C"], FC, P.OrFix<"K", F[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", F[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", F[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", F[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", F[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", F[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", F[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", F[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, any>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[Next[0]["_F"]] : A.NonEmptyArray<A>>[F[0]["_F"]] : A.NonEmptyArray<A>;
export declare const gen: <Eff extends P.GenLazyHKT<A.NonEmptyArray<any>, any>, AEff>(f: (i: {
    <A>(_: () => O.Option<A>): P.GenLazyHKT<A.NonEmptyArray<A>, A>;
    <A_1>(_: () => A.NonEmptyArray<A_1>): P.GenLazyHKT<A.NonEmptyArray<A_1>, A_1>;
}) => Generator<Eff, AEff, any>) => A.NonEmptyArray<AEff>;
export declare const tuple: <T extends A.NonEmptyArray<unknown>[], K = any, Q = any, W = any, X = any, I = any, S = any, R = any, E = any>(...t: T & {
    readonly 0: A.NonEmptyArray<unknown>;
}) => A.NonEmptyArray<{ [K_1 in keyof T]: [T[K_1]] extends [A.NonEmptyArray<infer A>] ? A : never; }>;
export declare const struct: <NER extends Record<string, A.NonEmptyArray<unknown>>, K = any, Q = any, W = any, X = any, I = any, S = any, R = any, E = any>(r: import("@effect-ts/system/Utils/index.js").EnforceNonEmptyRecord<NER> & Record<string, A.NonEmptyArray<unknown>>) => A.NonEmptyArray<{ [K_1 in keyof NER]: P.Infer<[P.URI<"NonEmptyArray", {}>], P.Auto, "A", NER[K_1]>; }>;
declare const do_: A.NonEmptyArray<{}>;
export declare const bind: <K2, Q2, W2, X2, I2, S2, R2, E2, BK, BN extends string, BA>(tag: Exclude<BN, keyof BK>, f: (a: BK) => A.NonEmptyArray<BA>) => <K, Q, W, X, I, S, R, E>(fa: A.NonEmptyArray<BK>) => A.NonEmptyArray<BK & { [k in BN]: BA; }>;
declare const let_: <BK, BN extends string, BA>(tag: Exclude<BN, keyof BK>, f: (a: BK) => BA) => <K, Q, W, X, I, S, R, E>(fa: A.NonEmptyArray<BK>) => A.NonEmptyArray<BK & { [k in BN]: BA; }>;
export { do_ as do, let_ as let };
/**
 * Matchers
 */
export declare const match: <N extends string>(tag: N) => P.MatchFn<[P.URI<"NonEmptyArray", {}>], P.Auto, N>, matchIn: <N extends string>(tag: N) => P.MatchInFn<[P.URI<"NonEmptyArray", {}>], P.Auto, N>, matchMorph: <N extends string, X extends { [tag in N]: string; }>(MorphADT: {
    tag: N;
    _A: X;
}) => P.MatchMorphFn<[P.URI<"NonEmptyArray", {}>], P.Auto, N, X>, matchTag: P.MatchFn<[P.URI<"NonEmptyArray", {}>], P.Auto, "_tag">, matchTagIn: P.MatchInFn<[P.URI<"NonEmptyArray", {}>], P.Auto, "_tag">;
/**
 * Conditionals
 */
declare const branch: <X extends A.NonEmptyArray<any>, Y extends A.NonEmptyArray<any>>(onTrue: () => X, onFalse: () => Y) => (predicate: boolean) => A.NonEmptyArray<P.Infer<[P.URI<"NonEmptyArray", {}>], P.Auto, "A", X | Y>>;
declare const branch_: <X extends A.NonEmptyArray<any>, Y extends A.NonEmptyArray<any>>(predicate: boolean, onTrue: () => X, onFalse: () => Y) => A.NonEmptyArray<P.Infer<[P.URI<"NonEmptyArray", {}>], P.Auto, "A", X | Y>>;
export { branch as if, branch_ as if_ };
//# sourceMappingURL=dsl.d.ts.map