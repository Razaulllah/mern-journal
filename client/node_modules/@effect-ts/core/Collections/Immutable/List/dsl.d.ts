import * as P from "../../../Prelude/index.js";
/**
 * `ForEach`'s `sequenceF` derivation
 */
export declare const sequenceF: <F extends P.URIS, FC>(App: P.Covariant<F, FC> & P.IdentityBoth<F, FC>) => <K, Q, W, X, I, S, R, E, FK, FQ, FW, FX, FI, FS, FR, FE, A>(_: import("@effect-ts/system/Collections/Immutable/List/core.js").List<F extends [any, ...infer Next] ? P.URItoKind<F[0]["_C"], FC, P.OrFix<"K", F[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", F[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", F[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", F[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", F[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", F[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", F[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", F[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, any>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[Next[0]["_F"]] : A>[F[0]["_F"]] : A>) => F extends [any, ...infer Next] ? P.URItoKind<F[0]["_C"], FC, P.OrFix<"K", F[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", F[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", F[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", F[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", F[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", F[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", F[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", F[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, Next extends [any, ...infer Next] ? P.URItoKind<Next[0]["_C"], FC, P.OrFix<"K", Next[0]["_C"], P.OrFix<"K", FC, FK>>, P.OrFix<"Q", Next[0]["_C"], P.OrFix<"Q", FC, FQ>>, P.OrFix<"W", Next[0]["_C"], P.OrFix<"W", FC, FW>>, P.OrFix<"X", Next[0]["_C"], P.OrFix<"X", FC, FX>>, P.OrFix<"I", Next[0]["_C"], P.OrFix<"I", FC, FI>>, P.OrFix<"S", Next[0]["_C"], P.OrFix<"S", FC, FS>>, P.OrFix<"R", Next[0]["_C"], P.OrFix<"R", FC, FR>>, P.OrFix<"E", Next[0]["_C"], P.OrFix<"E", FC, FE>>, any>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[Next[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>>[F[0]["_F"]] : import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>;
/**
 * Generator
 */
export declare const gen: <Eff extends P.GenLazyHKT<import("@effect-ts/system/Collections/Immutable/List/core.js").List<any>, any>, AEff>(f: (i: <K, Q, W, X, I, S, R, E, A>(_: () => import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>) => P.GenLazyHKT<import("@effect-ts/system/Collections/Immutable/List/core.js").List<A>, A>) => Generator<Eff, AEff, any>) => import("@effect-ts/system/Collections/Immutable/List/core.js").List<AEff>;
/**
 * Struct derivation
 */
export declare const struct: <NER extends Record<string, import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>>, K = any, Q = any, W = any, X = any, I = any, S = any, R = any, E = any>(r: import("@effect-ts/system/Utils/index.js").EnforceNonEmptyRecord<NER> & Record<string, import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>>) => import("@effect-ts/system/Collections/Immutable/List/core.js").List<{ [K_1 in keyof NER]: P.Infer<[P.URI<"List", {}>], P.Auto, "A", NER[K_1]>; }>;
/**
 * Tuple derivation
 */
export declare const tuple: <T extends import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>[], K = any, Q = any, W = any, X = any, I = any, S = any, R = any, E = any>(...t: T & {
    readonly 0: import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>;
}) => import("@effect-ts/system/Collections/Immutable/List/core.js").List<{ [K_1 in keyof T]: [T[K_1]] extends [import("@effect-ts/system/Collections/Immutable/List/core.js").List<infer A>] ? A : never; }>;
/**
 * Struct derivation
 */
export declare const structZip: <NER extends Record<string, import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>>, K = any, Q = any, W = any, X = any, I = any, S = any, R = any, E = any>(r: import("@effect-ts/system/Utils/index.js").EnforceNonEmptyRecord<NER> & Record<string, import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>>) => import("@effect-ts/system/Collections/Immutable/List/core.js").List<{ [K_1 in keyof NER]: P.Infer<[P.URI<"List", {}>], P.Auto, "A", NER[K_1]>; }>;
/**
 * Tuple derivation
 */
export declare const tupleZip: <T extends import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>[], K = any, Q = any, W = any, X = any, I = any, S = any, R = any, E = any>(...t: T & {
    readonly 0: import("@effect-ts/system/Collections/Immutable/List/core.js").List<unknown>;
}) => import("@effect-ts/system/Collections/Immutable/List/core.js").List<{ [K_1 in keyof T]: [T[K_1]] extends [import("@effect-ts/system/Collections/Immutable/List/core.js").List<infer A>] ? A : never; }>;
/**
 * Matchers
 */
export declare const match: <N extends string>(tag: N) => P.MatchFn<[P.URI<"List", {}>], P.Auto, N>, matchIn: <N extends string>(tag: N) => P.MatchInFn<[P.URI<"List", {}>], P.Auto, N>, matchMorph: <N extends string, X extends { [tag in N]: string; }>(MorphADT: {
    tag: N;
    _A: X;
}) => P.MatchMorphFn<[P.URI<"List", {}>], P.Auto, N, X>, matchTag: P.MatchFn<[P.URI<"List", {}>], P.Auto, "_tag">, matchTagIn: P.MatchInFn<[P.URI<"List", {}>], P.Auto, "_tag">;
//# sourceMappingURL=dsl.d.ts.map