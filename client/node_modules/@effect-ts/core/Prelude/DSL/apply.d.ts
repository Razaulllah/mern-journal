import type { EnforceNonEmptyRecord } from "../../Utils/index.js";
import type { Apply } from "../Apply/index.js";
import type * as HKT from "../HKT/index.js";
export declare function apF<F extends HKT.URIS, C>(F: Apply<F, C>): <K, Q, W, X, I, S, R, E, A>(fa: HKT.Kind<F, C, K, Q, W, X, I, S, R, E, A>) => <K2, Q2, W2, X2, I2, S2, R2, E2, B>(fab: HKT.Kind<F, C, HKT.Intro<C, "K", K, K2>, HKT.Intro<C, "Q", Q, Q2>, HKT.Intro<C, "W", W, W2>, HKT.Intro<C, "X", X, X2>, HKT.Intro<C, "I", I, I2>, HKT.Intro<C, "S", S, S2>, HKT.Intro<C, "R", R, R2>, HKT.Intro<C, "E", E, E2>, (a: A) => B>) => HKT.Kind<F, C, HKT.Mix<C, "K", [K, K2]>, HKT.Mix<C, "Q", [Q, Q2]>, HKT.Mix<C, "W", [W, W2]>, HKT.Mix<C, "X", [X, X2]>, HKT.Mix<C, "I", [I, I2]>, HKT.Mix<C, "S", [S, S2]>, HKT.Mix<C, "R", [R, R2]>, HKT.Mix<C, "E", [E, E2]>, B>;
export declare function structF<F extends HKT.URIS, C = HKT.Auto>(F: Apply<F, C>): <NER extends Record<string, HKT.Kind<F, C, HKT.Intro<C, "K", K, any>, HKT.Intro<C, "Q", Q, any>, HKT.Intro<C, "W", W, any>, HKT.Intro<C, "X", X, any>, HKT.Intro<C, "I", I, any>, HKT.Intro<C, "S", S, any>, HKT.Intro<C, "R", R, any>, HKT.Intro<C, "E", E, any>, unknown>>, K = HKT.Initial<C, "K">, Q = HKT.Initial<C, "Q">, W = HKT.Initial<C, "W">, X = HKT.Initial<C, "X">, I = HKT.Initial<C, "I">, S = HKT.Initial<C, "S">, R = HKT.Initial<C, "R">, E = HKT.Initial<C, "E">>(r: EnforceNonEmptyRecord<NER> & Record<string, HKT.Kind<F, C, HKT.Intro<C, "K", K, any>, HKT.Intro<C, "Q", Q, any>, HKT.Intro<C, "W", W, any>, HKT.Intro<C, "X", X, any>, HKT.Intro<C, "I", I, any>, HKT.Intro<C, "S", S, any>, HKT.Intro<C, "R", R, any>, HKT.Intro<C, "E", E, any>, unknown>>) => HKT.Kind<F, C, HKT.Infer<F, C, "K", NER[keyof NER]>, HKT.Infer<F, C, "Q", NER[keyof NER]>, HKT.Infer<F, C, "W", NER[keyof NER]>, HKT.Infer<F, C, "X", NER[keyof NER]>, HKT.Infer<F, C, "I", NER[keyof NER]>, HKT.Infer<F, C, "S", NER[keyof NER]>, HKT.Infer<F, C, "R", NER[keyof NER]>, HKT.Infer<F, C, "E", NER[keyof NER]>, {
    [K in keyof NER]: HKT.Infer<F, C, "A", NER[K]>;
}>;
export declare function tupleF<F extends HKT.URIS, C>(F: Apply<F, C>): <T extends Array<HKT.Kind<F, C, HKT.Intro<C, "K", K, any>, HKT.Intro<C, "Q", Q, any>, HKT.Intro<C, "W", W, any>, HKT.Intro<C, "X", X, any>, HKT.Intro<C, "I", I, any>, HKT.Intro<C, "S", S, any>, HKT.Intro<C, "R", R, any>, HKT.Intro<C, "E", E, any>, unknown>>, K = HKT.Initial<C, "K">, Q = HKT.Initial<C, "Q">, W = HKT.Initial<C, "W">, X = HKT.Initial<C, "X">, I = HKT.Initial<C, "I">, S = HKT.Initial<C, "S">, R = HKT.Initial<C, "R">, E = HKT.Initial<C, "E">>(...t: T & {
    readonly 0: HKT.Kind<F, C, HKT.Intro<C, "K", K, any>, HKT.Intro<C, "Q", Q, any>, HKT.Intro<C, "W", W, any>, HKT.Intro<C, "X", X, any>, HKT.Intro<C, "I", I, any>, HKT.Intro<C, "S", S, any>, HKT.Intro<C, "R", R, any>, HKT.Intro<C, "E", E, any>, unknown>;
}) => HKT.Kind<F, C, HKT.Infer<F, C, "K", T[number]>, HKT.Infer<F, C, "Q", T[number]>, HKT.Infer<F, C, "W", T[number]>, HKT.Infer<F, C, "X", T[number]>, HKT.Infer<F, C, "I", T[number]>, HKT.Infer<F, C, "S", T[number]>, HKT.Infer<F, C, "R", T[number]>, HKT.Infer<F, C, "E", T[number]>, {
    [K in keyof T]: [T[K]] extends [
        HKT.Kind<F, C, any, any, any, any, any, any, any, any, infer A>
    ] ? A : never;
}>;
//# sourceMappingURL=apply.d.ts.map